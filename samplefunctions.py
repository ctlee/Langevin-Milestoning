"""
@description: Performs a 1D Langevin dynamics simulation to validate the results
        of the milestoning pemreability derivation
@authors:   Christopher T. Lee (ctlee@ucsd.edu)
@copyright Amaro Lab 2015. All rights reserved.
"""
import sys
import numpy as np
from scipy.interpolate import UnivariateSpline
from scipy.interpolate import PchipInterpolator as pchip
import matplotlib
if sys.platform == 'darwin':
    matplotlib.use('macosx') # cocoa rendering for Mac OS X

import matplotlib.pyplot as plt
import plottools

class PMF(object):
    r"""
    A class to represent the potential of mean force (PMF). The PMF is 
    represented by a Piecewise Cubic Hermite Interpolating Polynomial 
    (PCHIP) generated by the user-specified parameters below.

    Parameters
    ----------
    dz : float 
        distance from center to edge of membrane
    w1 : float
        PMF at interface in units of kgA^2s^-2
    w2 : float
        PMF at interface/core
    w3 : float
        PMF at core
    a : float
        location of interface (:py:data:`w1`)
    b : float
        location of interface/core (:py:data:`w2`)

    Notes
    -----
    - :py:data:`w1`, :py:data:`w2`, and :py:data:`w3` should be specified in 
      units of :math:`kg A^2 s^{-2} mol^{-1}`.
    - All distances are given in units of Angstroms
    """
    def __init__(self, dz, w1, w2, w3, a, b):
        # INFO 1kcal = 4184e20 kg A^2 s^-2
        # TODO check bounds of a, b
        self.dz = dz
        self.x = np.array([-dz, -dz+1, -a, -b, 0, b, a, dz-1, dz])
        self.y = np.array([0, 0, w1, w2, w3, w2, w1, 0, 0])
        self.pmf = pchip(self.x, self.y)
        self.derivative = self.pmf.derivative(1)

    def __call__(self, x, nu = 0):
        r"""
        Get the value at a given position or positions of the derivative 
        :py:data:`nu` of the function.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate
        nu : int
            The order of derivative

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the PMF
        """
        return self.pmf(x, nu = nu, extrapolate=True)
    
    def energy(self, x):
        r"""
        Get the PMF at a given position or positions.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate the energy

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the PMF
        """
        return self.pmf(x, extrapolate=True)

    def force(self, x):
        r"""
        Get the force at a given position(s) according to 
        :math:`F(z) = -\nabla W(z)`.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate the force

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the force
        """
        return -self.derivative(x, extrapolate=True)

    def plot(self, fignum = 1):
        r"""
        Generate a nice plot of the interpolated PMF and force.

        Parameters
        ----------
        fignum : int
            The figure number to generate

        Returns
        -------
        fig : matplotlib.pyplot.figure
            MatPlotLib figure for future manipulation and saving
        """
        
        scalefactor = 1.43929254302   # conversion to kcal/mol
        extraBound = 5
        
        fig = plt.figure(fignum, facecolor='white', figsize=(7, 5.6))
        ax1 = fig.add_subplot(111)

        x = np.arange(-self.dz-extraBound, self.dz+extraBound+0.1, 0.1)
        pmf = self.energy(x)*scalefactor
        
        ax1.plot(self.x, self.y*scalefactor, 'o', label='Supplied Values')
        ax1.plot(x, pmf, label='Spline of PMF')
        ax1.set_ylabel(r'PMF [$kcal/mol$]')
        ax1.set_xlabel(r'Position [$\AA$]')

        ax2 = ax1.twinx()
        force = self.force(x)*scalefactor
        ax2.plot(x, force, label=r'Force [$-dPMF/dx$]')

        handles1, labels1 = ax1.get_legend_handles_labels()
        handles2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(handles1 + handles2, labels1 + labels2, 
                loc = 'lower left',
                fontsize = 'small',
                frameon = False)

        ax1.margins(0,0.05)
        ax2.margins(0,0.2)

        lim = [-1,1]
        if ax1.get_ylim()[0] > ax2.get_ylim()[0]:   # Pick the lesser
            lim[0] = ax2.get_ylim()[0]
        else:
            lim[0] = ax1.get_ylim()[0]

        if ax1.get_ylim()[1] > ax2.get_ylim()[1]:
            lim[1] = ax1.get_ylim()[1]
        else:
            lim[1] = ax2.get_ylim()[1]
        ax1.set_ylim(lim)
        ax2.set_ylim(lim)
        return fig
    
class Viscosity(object):
    # TODO document this function
    def __init__(self, dz, d1, d2, d3, d4, a, b, c):
        self.dz = dz
        self.x = [-dz, -a, -b, -c, 0, c, b, a, dz]
        self.y = [d1, d1, d2, d3, d4, d3, d2, d1, d1]
        self.pchip = pchip(self.x, self.y)

    #@jit(nogil=True)
    def __call__(self, x):
        return self.pchip(x, extrapolate = True)

    def plot(self, fignum = 1):
        extraBound = 5
        
        fig = plt.figure(fignum, facecolor='white', figsize=(7,5.6))
        ax1 = fig.add_subplot(111)
        ax1.margins(0,0.05)
        ax1.set_yscale('log')
        x = np.arange(-self.dz-extraBound, self.dz+extraBound+0.1, 0.1)
        y = self.pchip(x)
        ax1.plot(self.x, self.y, 'o', x, y)
        ax1.set_ylabel(r'Viscosity [$kg/\AA\cdot s$]')
        ax1.set_xlabel(r'Position [$\AA$]')
