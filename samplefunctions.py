################################################################################
# langevin-milestoning: A Langevin dynamics engine
# 
# Copyright 2016 The Regents of the University of California.
#
# Authors: Christopher T. Lee <ctlee@ucsd.edu>
#          Lane W. Votapka <lvotapka100@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################

r"""
A module which provides support for arbitraty PMF and viscosity profiles
interpolated from user provided inputs.

Please reference the following if you use this code in your research:

[1] L. W. Votapka*, C. T. Lee*, and R.E. Amaro. Two Relations to Estimate
Permeability Using Milestoning. J. Phys. Chem. B. 2016. (Accepted)
"""
__authors__ = "Christopher T. Lee and Lane W. Votapka"
__license__ = "Apache 2.0"

import sys
import numpy as np
from scipy.interpolate import PchipInterpolator as pchip

import matplotlib
if sys.platform == 'darwin':
    matplotlib.use('macosx') # cocoa rendering for Mac OS X
import matplotlib.pyplot as plt
import plottools

class PMF(object):
    r"""
    A class to represent the potential of mean force (PMF). The PMF is 
    represented by a Piecewise Cubic Hermite Interpolating Polynomial 
    (PCHIP) generated by the user-specified parameters below.

    Parameters
    ----------
    dz : float 
        Distance from center to edge of membrane
    w1 : float
        PMF at interface in units of kgA^2s^-2
    w2 : float
        PMF at interface/core
    w3 : float
        PMF at core
    a : float
        Location of interface (:py:data:`w1`)
    b : float
        Location of interface/core (:py:data:`w2`)

    Notes
    -----
    - :py:data:`w1`, :py:data:`w2`, and :py:data:`w3` should be specified in 
      units of :math:`kg A^2 s^{-2} mol^{-1}`.
    - All distances are given in units of Angstroms
    """
    def __init__(self, dz, w1, w2, w3, a, b):
        # INFO 1kcal = 4184e20 kg A^2 s^-2
        # TODO check bounds of a, b
        self.dz = dz
        self.x = np.array([-dz, -dz+1, -a, -b, 0, b, a, dz-1, dz])
        self.y = np.array([0, 0, w1, w2, w3, w2, w1, 0, 0])
        self.pmf = pchip(self.x, self.y)
        self.derivative = self.pmf.derivative(1)

    def __call__(self, x, nu = 0):
        r"""
        Get the value at a given position or positions of the derivative 
        :py:data:`nu` of the function.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate
        nu : int
            The order of derivative

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the PMF
        """
        return self.pmf(x, nu = nu, extrapolate=True)
    
    def energy(self, x):
        r"""
        Get the PMF at a given position or positions.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate the energy

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the PMF
        """
        return self.pmf(x, extrapolate=True)

    def force(self, x):
        r"""
        Get the force at a given position(s) according to 
        :math:`F(z) = -\nabla W(z)`.

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate the force

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the force
        """
        return -self.derivative(x, extrapolate=True)

    def plot(self, fignum = 1):
        r"""
        Generate a nice plot of the interpolated PMF and force.

        Parameters
        ----------
        fignum : int
            The figure number to generate

        Returns
        -------
        fig : matplotlib.pyplot.figure
            MatPlotLib figure for future manipulation and saving
        """
        
        scalefactor = 1.43929254302   # conversion to kcal/mol
        extraBound = 5
        
        fig = plt.figure(fignum, facecolor='white', figsize=(7, 5.6))
        ax1 = fig.add_subplot(111)

        x = np.arange(-self.dz-extraBound, self.dz+extraBound+0.1, 0.1)
        pmf = self.energy(x)*scalefactor
        
        ax1.plot(self.x, self.y*scalefactor, 'o', label='Supplied Values')
        ax1.plot(x, pmf, label='Spline of PMF')
        ax1.set_ylabel(r'PMF [$kcal/mol$]')
        ax1.set_xlabel(r'Position [$\AA$]')

        ax2 = ax1.twinx()
        force = self.force(x)*scalefactor
        ax2.plot(x, force, label=r'Force [$-dPMF/dx$]')

        handles1, labels1 = ax1.get_legend_handles_labels()
        handles2, labels2 = ax2.get_legend_handles_labels()
        ax1.legend(handles1 + handles2, labels1 + labels2, 
                loc = 'lower left',
                fontsize = 'small',
                frameon = False)

        ax1.margins(0,0.05)
        ax2.margins(0,0.2)

        lim = [-1,1]
        if ax1.get_ylim()[0] > ax2.get_ylim()[0]:   # Pick the lesser
            lim[0] = ax2.get_ylim()[0]
        else:
            lim[0] = ax1.get_ylim()[0]

        if ax1.get_ylim()[1] > ax2.get_ylim()[1]:
            lim[1] = ax1.get_ylim()[1]
        else:
            lim[1] = ax2.get_ylim()[1]
        ax1.set_ylim(lim)
        ax2.set_ylim(lim)
        return fig
    
class Viscosity(object):
    r"""
    A class to encapsulate the Viscosity profile 

    Parameters
    ----------
    dz : float 
        Distance from center to edge of membrane
    d1 : float
        Viscosity in bulk in units of kgA^2s^-2
    d2 : float
        Viscosity the interface
    d3 : float
        Viscosity at the interface/core
    d4 : float
        Viscosity at core
    a : float
        location of bulk (:py:data:`d1`)
    b : float
        location of interface (:py:data:`d2`)
    c : float
        location of interface/core (:py:data:`d3`)
    
    Notes
    -----
    - :py:data:`d1`, :py:data:`w2`, :py:data:`w3`, and :py:data:`d4` should be 
      specified in units of :math:`kg A^{-1} s^{-1}`.
    - All distances are given in units of Angstroms
    """
    def __init__(self, dz, d1, d2, d3, d4, a, b, c):
        self.dz = dz
        self.x = [-dz, -a, -b, -c, 0, c, b, a, dz]
        self.y = [d1, d1, d2, d3, d4, d3, d2, d1, d1]
        self.pchip = pchip(self.x, self.y)

    def __call__(self, x):
        r"""
        Get the value at a given position or positions of the Viscosity

        Parameters
        ----------
        x : np.ndarray, float
            x is(are) the position(s) at which to evaluate

        Returns
        -------
        y : np.ndarray, float
            Interpolated values of the Viscosity
        """
        return self.pchip(x, extrapolate = True)

    def plot(self, fignum = 1):
        r"""
        Generate a nice plot of the interpolated PMF and force.

        Parameters
        ----------
        fignum : int
            The figure number to generate

        Returns
        -------
        fig : matplotlib.pyplot.figure
            MatPlotLib figure for future manipulation and saving
        """
        extraBound = 5
        
        fig = plt.figure(fignum, facecolor='white', figsize=(7,5.6))
        ax1 = fig.add_subplot(111)
        ax1.margins(0,0.05)
        ax1.set_yscale('log')
        x = np.arange(-self.dz-extraBound, self.dz+extraBound+0.1, 0.1)
        y = self.pchip(x)
        ax1.plot(self.x, self.y, 'o', x, y)
        ax1.set_ylabel(r'Viscosity [$kg/\AA\cdot s$]')
        ax1.set_xlabel(r'Position [$\AA$]')
